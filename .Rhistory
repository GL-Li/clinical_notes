save(note_bows, word_stats, file = "./shiny-apps/RData/medical_entities_bow.RData")
runApp('shiny-apps')
library(shiny)
library(shinydashboard)
runApp('shiny-apps')
runApp('shiny-apps')
library(data.table)
library(magrittr)
library(stringr)
library(tm)
library(caret)
library(progress)
library(dendextend)
source("utilities.R")
a = NULL
isTRUE((a))
iisTRUE(a)
isTRUE(a)
read_notes <- function(csv_file, clean = NULL, y_label = NULL){
# read clinical notes and add label y to the original data
#
# Arguments:
#   csv_file: string, path to the the data file
#   clean: boolean, if TRUE add missing space after ".", for example,
#     "abscess.PROCEDURE".
#   y_label: boolean, if TRUE, add a class label 0, 1, 2, ... to each note
#
# Return:
#   a data.table
dat <- fread(csv_file)
if (isTRUE(clean)){
# missing space after ".", for example "abscess.PROCEDURE"
dat[, note := str_replace_all(note, "\\.", "\\. ")]
}
if (isTRUE(y_label)){
dat[, y := as.integer(factor(specialty)) - 1]
}
}
source("utilities.R")
load("./shiny-apps/RData/medical_entities_bow.RData")
note_bows[, target := ifelse(sample_type == "Gastroenterology", 1, 2)]
note_bows
names(note_bows)
dat <- read_notes("data/mtsamples_gastroenterology_neurology.csv",
clean = TRUE,
y_label = TRUE)
names(dat)
notes <- dat$note
tfidf <- tfidf_tm(dat$note)
rowSums(tfidt * tfidf)
rowSums(tfidf * tfidf)
y <- dat$y
# how many clusters ============================================================
k <- kmeans(tfidf, 3, iter.max = 100)
k
# how many clusters ============================================================
k <- kmeans(tfidf, 2, iter.max = 100)
k
# how many clusters ============================================================
k <- kmeans(tfidf, 1, iter.max = 100)
k
# how many clusters ============================================================
k <- kmeans(tfidf, 4, iter.max = 100)
k
k$withinss
k$tot.withinss
sum(k$withinss)
# how many clusters ============================================================
K = 10
inertia <- c()
for (k in 1:K){
km <- kmeans(tfidf, k, iter.max = 100)
inertia <- c(inertia, km$tot.withinss)
}
plot(1:K, inertia)
# how many clusters ============================================================
K = 100
inertia <- c()
for (k in 1:K){
km <- kmeans(tfidf, k, iter.max = 100)
inertia <- c(inertia, km$tot.withinss)
}
plot(1:K, inertia)
?kmeans
library(tsne)
install.packages("Rtsne")
library(Rtsne)
?tsne
?Rtsne
Rtsne(tfidf)
duplicated(tfidf)
sum(duplicated(tfidf))
duplicated(tfidf) == TRUE
which(duplicated(tfidf))
which(duplicated(tfidf))
aaa = tfidf[!duplicated(tfidf)]
aaa
aaa = tfidf[!duplicated(tfidf),]
Rtsne(aaa)
bbb = Rtsne(aaa)
plot(bbb$Y)
y
yy = y[c(1:339, 341:541)]
plot(bbb$Y, col = yy)
View(dat)
if ("A") print("aa")
duplicated(c("a", "b", "a"))
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_gastroenterology_neurology.csv",
clean = TRUE,
y_label = TRUE)
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_gastroenterology_neurology.csv",
clean = TRUE,
y_label = TRUE)
View(dat)
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_scraped.csv",
clean = TRUE,
y_label = TRUE)
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_scraped.csv",
clean = TRUE,
y_label = TRUE)
names(dat)
read_notes <- function(csv_file,
specialties = NULL,
y_label = NULL,
cols_keep = c("specialty", "note"),
duplicate_rm = TRUE,
clean = TRUE,
id = TRUE){
# read clinical notes and add label y to the original data
#
# Arguments:
#   csv_file: string, path to the the data file
#   specialties: string vector, selected specialties such as
#     c("Gastroenterology", "Neurology")
#   cols_keep: columns in the orignial data to keep
#   y_label: boolean, if TRUE, add a class label 0, 1, 2, ... to each note
#   duplicate_rm: boolean, remove rows if duplicated in column note
#   clean: boolean, if TRUE add missing space after ".", for example,
#     "abscess.PROCEDURE".
#   id: boolean, add id to each sample after removing duplicates
#
# Return:
#   a data.table
dat <- fread(csv_file)
if (!is.null(specialties)){
dat <- dat[specialty %in% specialties]
}
if (isTRUE(clean)){
# missing space after ".", for example "abscess.PROCEDURE"
dat[, note := str_replace_all(note, "\\.", "\\. ")]
}
if (isTRUE(y_label)){
dat[, y := as.integer(factor(specialty)) - 1]
}
if (duplicate_rm){
rows_duplicated <- duplicated(dat$note)
dat <- dat[!rows_duplicated]
cat(paste("Deleted", sum(rows_duplicated),
"rows with duplicated notes"))
}
if (id){
dat[, id := 1:nrow(dat)]
setcolorder(dat, c("id", setdiff(names(dat), "id")))
}
}
dat <- read_notes("data/mtsamples_scraped.csv",
clean = TRUE,
y_label = TRUE)
names(dat)
list(1:3)
cols_keep = c("specialty", "note"),
cols_keep = c("specialty", "note")
dat[, cols_keep]
dat[, (cols_keep)]
dat[, .(cols_keep)]
dat[, cols_keep, with = TRUE]
dat[, ..cols_keep]
dat[, ..cols_keep] -> vvv
View(vvv)
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_scraped.csv",
clean = TRUE,
y_label = TRUE)
View(dat)
identical(cols_keep, "all")
source('~/Dropbox/work-with-health-data/clinical_notes/utilities.R')
dat <- read_notes("data/mtsamples_scraped.csv",
clean = TRUE,
y_label = TRUE)
names(dat)
?read_notes
dat <- read_notes("data/mtsamples_scraped.csv",
specialties = c("Gastroenterology", "Neurology"),
clean = TRUE,
y_label = TRUE)
dat <- read_notes("data/mtsamples_scraped.csv",
specialties = c("Gastroenterology", "Neurology", "Urology"),
clean = TRUE,
y_label = TRUE)
# tfidf matrix
tfidf <- tfidf_tm(dat$note)
y <- dat$y
# how many clusters ============================================================
# tsne analysis https://github.com/jkrijthe/Rtsne
K = 10
inertia <- c()
for (k in 1:K){
print(k)
km <- kmeans(tfidf, k, iter.max = 100)
inertia <- c(inertia, km$tot.withinss)
}
plot(1:K, inertia)
km <- kmeans(tfidf, 3, iter.max = 100)
km
predict(km, tfidf)
km$cluster
caret::confusionMatrix(as.factor(km$cluster - 1), as.factor(y))
y_clusters <- km$cluster
table(y, y_clusters - 1)
table(y, y_clusters)
# y_clusters
# y     1   2   3
#   0  76  87  67
#   1 202   0  20
#   2  51   0 103
# best match would be
# 1 --> 1, 2 --> 0, 3 --> 2
y_clusters <- switch (y_cluster,
1 = 1,
2, 0,
3, 2
)
# y_clusters
# y     1   2   3
#   0  76  87  67
#   1 202   0  20
#   2  51   0 103
# best match would be
# 1 --> 1, 2 --> 0, 3 --> 2
y_clusters <- switch (y_cluster,
1 = 1,
2, 0,
3, 2
)
switch()
?switch (object,
case = action
)
# y_clusters
# y     1   2   3
#   0  76  87  67
#   1 202   0  20
#   2  51   0 103
# best match would be
# 1 --> 1, 2 --> 0, 3 --> 2
y_clusters <- switch (y_cluster,
1 = 1,
2 = 0,
3 = 2
)
y_clusters <- switch (y_cluster,
1 = 1,
2 = 0,
3 = 2
)
y_clusters
# y_clusters
# y     1   2   3
#   0  76  87  67
#   1 202   0  20
#   2  51   0 103
# best match would be
# 1 --> 1, 2 --> 0, 3 --> 2
y_clusters[y_clusters == 2] <- 0
y_clusters[y_clusters == 3] <- 2
table(y, y_clusters)
View(dat)
caret::confusionMatrix(as.factor(y_clusters), as.factor(y))
# how to match cluster to true class
y_clusters <- km$cluster
c1 <- dat[y_clusters == 1]
View(c1)
c2 <- dat[y_clusters == 2]
View(c2)
c3 <- dat[y_clusters == 3]
View(c3)
# hierarchical clustering ======================================================
# https://cran.r-project.org/web/packages/textmineR/vignettes/b_document_clustering.html
# https://uc-r.github.io/hc_clustering
cos_sim <- tfidf %*% t(tfidf)
par(mar = rep(0, 4))
image(cos_sim * 256, col = gray(seq(0, 1, length = 256)))
image(cos_sim * 256, col = rgb(seq(0, 1, length = 256), 0, 0))
image(cos_sim * 256, col = gray(seq(0, 1, length = 256)))
# hierarchical clustering ======================================================
# https://cran.r-project.org/web/packages/textmineR/vignettes/b_document_clustering.html
# https://uc-r.github.io/hc_clustering
tfidf_rand <- tfidf[sample(nrow(tfidf)),]
cos_sim <- tfidf %*% t(tfidf)
par(mar = rep(0, 4))
image(cos_sim * 256, col = gray(seq(0, 1, length = 256)))
tfidf[1,]
tfidf[1,1:3]
tfidf_rand[1,1:3]
# hierarchical clustering ======================================================
# https://cran.r-project.org/web/packages/textmineR/vignettes/b_document_clustering.html
# https://uc-r.github.io/hc_clustering
tfidf_rand <- tfidf[sample(nrow(tfidf)),]
cos_sim <- tfidf %*% t(tfidf)
par(mar = rep(0, 4))
image(cos_sim * 256, col = gray(seq(0, 1, length = 256)))
dist <- as.dist(1 - cos_sim)
# ward.D and ward.D2 are good for clustering, slight difference
hc <- hclust(dist, "ward.D")
# plot dendrogram
# https://cran.r-project.org/web/packages/dendextend/vignettes/FAQ.html#introduction
dend <- as.dendrogram(hc)
sample_colors <- c(rep("red", 230), rep("blue", 221), rep("orange", 155))
dend <- assign_values_to_leaves_edgePar(
dend=dend,
value = sample_colors[order.dendrogram(dend)],
edgePar = "col"
)
par(mar = c(0, 0, 2, 0))
plot(dend, main = "Medical Notes Clustering",
leaflab = "none", yaxt = "none")
rect.hclust(hc, 2, border = "gray97")
rect.hclust(hc, 3, border = "gray97")
plot(dend, main = "Medical Notes Clustering",
leaflab = "none", yaxt = "none")
rect.hclust(hc, 3, border = "gray97")
read_notes <- function(csv_file,
specialties = NULL,
y_label = NULL,
cols_keep = c("specialty", "note"),
randomize = TRUE,
duplicate_rm = TRUE,
clean = TRUE,
id = TRUE){
# read clinical notes and add label y to the original data
#
# Arguments:
#   csv_file: string, path to the the data file
#   specialties: string vector, selected specialties such as
#     c("Gastroenterology", "Neurology")
#   cols_keep: string, columns in the orignial data to keep, "all" to keep
#     all columns.
#   randomize: boolean, randomize row (sample) orders to break grouping
#   y_label: boolean, if TRUE, add a class label 0, 1, 2, ... to each note
#   duplicate_rm: boolean, remove rows if duplicated in column note
#   clean: boolean, if TRUE add missing space after ".", for example,
#     "abscess.PROCEDURE".
#   id: boolean, add id to each sample after removing duplicates
#
# Return:
#   a data.table
dat <- fread(csv_file)
if (!is.null(specialties)){
dat <- dat[specialty %in% specialties]
}
if (!identical(cols_keep, "all")){
dat <- dat[, ..cols_keep]   # ..var select columns by variable
}
if (isTRUE(clean)){
# missing space after ".", for example "abscess.PROCEDURE"
dat[, note := str_replace_all(note, "\\.", "\\. ")]
}
if (isTRUE(y_label)){
dat[, y := as.integer(factor(specialty)) - 1]
}
if (duplicate_rm){
rows_duplicated <- duplicated(dat$note)
dat <- dat[!rows_duplicated]
message(paste("Deleted", sum(rows_duplicated),
"rows with duplicated notes"))
}
if (id){
dat[, id := 1:nrow(dat)]
setcolorder(dat, c("id", setdiff(names(dat), "id")))
}
}
dat <- read_notes("data/mtsamples_scraped.csv",
specialties = c("Gastroenterology", "Neurology", "Urology"),
clean = TRUE,
y_label = TRUE)
View(dat)
sample(10)
read_notes <- function(csv_file,
specialties = NULL,
y_label = NULL,
cols_keep = c("specialty", "note"),
randomize = TRUE,
duplicate_rm = TRUE,
clean = TRUE,
id = TRUE){
# read clinical notes and add label y to the original data
#
# Arguments:
#   csv_file: string, path to the the data file
#   specialties: string vector, selected specialties such as
#     c("Gastroenterology", "Neurology")
#   cols_keep: string, columns in the orignial data to keep, "all" to keep
#     all columns.
#   randomize: boolean, randomize row (sample) orders to break grouping
#   y_label: boolean, if TRUE, add a class label 0, 1, 2, ... to each note
#   duplicate_rm: boolean, remove rows if duplicated in column note
#   clean: boolean, if TRUE add missing space after ".", for example,
#     "abscess.PROCEDURE".
#   id: boolean, add id to each sample after removing duplicates
#
# Return:
#   a data.table
dat <- fread(csv_file)
if (!is.null(specialties)){
dat <- dat[specialty %in% specialties]
}
if (!identical(cols_keep, "all")){
dat <- dat[, ..cols_keep]   # ..var select columns by variable
}
if (randomize){
dat <- dat[sample(nrow(dat))]
}
if (isTRUE(clean)){
# missing space after ".", for example "abscess.PROCEDURE"
dat[, note := str_replace_all(note, "\\.", "\\. ")]
}
if (isTRUE(y_label)){
dat[, y := as.integer(factor(specialty)) - 1]
}
if (duplicate_rm){
rows_duplicated <- duplicated(dat$note)
dat <- dat[!rows_duplicated]
message(paste("Deleted", sum(rows_duplicated),
"rows with duplicated notes"))
}
if (id){
dat[, id := 1:nrow(dat)]
setcolorder(dat, c("id", setdiff(names(dat), "id")))
}
}
dat <- read_notes("data/mtsamples_scraped.csv",
specialties = c("Gastroenterology", "Neurology", "Urology"),
clean = TRUE,
y_label = TRUE)
View(dat)
# tfidf matrix
tfidf <- tfidf_tm(dat$note)
y <- dat$y
y
cos_sim <- tfidf %*% t(tfidf)
par(mar = rep(0, 4))
image(cos_sim * 256, col = gray(seq(0, 1, length = 256)))
dist <- as.dist(1 - cos_sim)
# ward.D and ward.D2 are good for clustering, slight difference
hc <- hclust(dist, "ward.D")
# plot dendrogram
# https://cran.r-project.org/web/packages/dendextend/vignettes/FAQ.html#introduction
dend <- as.dendrogram(hc)
sample_colors <- c(rep("red", 230), rep("blue", 221), rep("orange", 155))
dend <- assign_values_to_leaves_edgePar(
dend=dend,
value = sample_colors[order.dendrogram(dend)],
edgePar = "col"
)
par(mar = c(0, 0, 2, 0))
plot(dend, main = "Medical Notes Clustering",
leaflab = "none", yaxt = "none")
# use true y to assign color
sample_colors <- rep(character(0), nrow(tfidf))
# plot dendrogram
# https://cran.r-project.org/web/packages/dendextend/vignettes/FAQ.html#introduction
dend <- as.dendrogram(hc)
# use true y to assign color
sample_colors <- rep(character(0), nrow(tfidf))
sample_colors[y == 0] <- "red"
sample_colors[y == 1] <- "blue"
sample_colors[y == 2] <- "orange"
dend <- assign_values_to_leaves_edgePar(
dend=dend,
value = sample_colors[order.dendrogram(dend)],
edgePar = "col"
)
par(mar = c(0, 0, 2, 0))
plot(dend, main = "Medical Notes Clustering",
leaflab = "none", yaxt = "none")
library("utilities.R")
source("utilities.R")
# all mt sample with thress columns specialty, note, section ==================
mtsamples_all <- fread("./data/mtsample_scraped.csv") %>%
.[, .(specialty, note, sections)]
# all mt sample with thress columns specialty, note, section ==================
mtsamples_all <- fread("./data/mtsamples_scraped.csv") %>%
.[, .(specialty, note, sections)]
save(mtsamples_all, file = "./shiny-apps/RData/mtsamples_all.RData")
# all mt samples as scraped ==================
mtsamples_all <- fread("./data/mtsamples_scraped.csv")
save(mtsamples_all, file = "./shiny-apps/RData/mtsamples_all.RData")
shiny::runApp('shiny-apps')
runApp('shiny-apps')
shiny::runApp('shiny-apps')
runApp('shiny-apps')
shiny::runApp('shiny-apps')
runApp('shiny-apps')
runApp('shiny-apps')
shiny::runApp('shiny-apps')
shiny::runApp('shiny-apps')
runApp('shiny-apps')
